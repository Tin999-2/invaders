<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Mahjong 64 - Digital Rain</title>
    <style>
        :root {
            --bg-color: #020205; /* より深い黒 */
            --tile-bg: #111125;
            --color-1: #00f3ff;
            --color-2: #ff00ff;
            --color-3: #00ff66;
            --color-4: #ffcc00;
            --danger: #ff3333;
        }

        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Consolas', monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        /* === 背景のキャンバス === */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* 最背面へ */
            opacity: 0.4; /* タイルが見やすいよう半透明に */
        }

        #ui { margin-bottom: 20px; font-size: 1.2rem; color: var(--color-1); text-shadow: 0 0 5px var(--color-1); }

        #game-view {
            position: relative;
            width: 700px; height: 550px;
            perspective: 1200px;
        }

        #tile-container, #particle-container {
            position: absolute; width: 100%; height: 100%;
        }
        #tile-container { z-index: 10; }
        #particle-container { z-index: 100; pointer-events: none; }

        .tile {
            position: absolute;
            width: 54px; height: 74px;
            background: var(--tile-bg);
            border: 1px solid #333; border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.15s ease;
            box-sizing: border-box; filter: brightness(0.5);
            box-shadow: 3px 3px 8px rgba(0,0,0,0.8);
            backdrop-filter: blur(2px); /* 背景を少しぼかす */
        }

        .tile.selected {
            filter: brightness(1.3) !important;
            border: 2px solid white;
            box-shadow: 0 0 25px var(--glow-color), inset 0 0 10px var(--glow-color);
            transform: translateZ(25px) scale(1.05);
            z-index: 1000 !important;
        }
        .tile svg { width: 38px; height: 38px; pointer-events: none; }

        .particle {
            position: absolute; width: 6px; height: 6px; border-radius: 50%;
            background-color: var(--p-color);
            animation: explode 0.7s cubic-bezier(0.1, 0.8, 0.3, 1) forwards;
        }
        @keyframes explode {
            0% { transform: translate(0, 0) scale(1.5); opacity: 1; }
            100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; }
        }

        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none;
            flex-direction: column; align-items: center; justify-content: center;
            z-index: 9999;
        }
        .btn {
            background: none; border: 1px solid var(--color-1); color: var(--color-1);
            padding: 15px 40px; font-size: 1.2rem; cursor: pointer; margin-top: 30px;
        }
    </style>
</head>
<body>

<canvas id="matrix-bg"></canvas>

<div id="ui">Node_Status: <span id="counter">64</span> / 64 Pairs_Available: <span id="moves">?</span></div>

<div id="game-view">
    <div id="tile-container"></div>
    <div id="particle-container"></div>
</div>

<div id="complete-screen" class="overlay">
    <h1 style="color: var(--color-2); font-size: 3rem;">COMPLETE</h1>
    <button class="btn" onclick="location.reload()">REBOOT</button>
</div>
<div id="fail-screen" class="overlay">
    <h1 style="color: var(--danger); font-size: 3rem;">CRITICAL ERROR</h1>
    <button class="btn" onclick="location.reload()">RESTART SYSTEM</button>
</div>

<script>
    // === デジタルレインの描画処理 ===
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
    const latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const nums = '0123456789';
    const alphabet = katakana + latin + nums;

    const fontSize = 16;
    const columns = canvas.width/fontSize;

    const rainDrops = [];
    for( let x = 0; x < columns; x++ ) {
        rainDrops[x] = 1;
    }

    const draw = () => {
        // 前のフレームを半透明の黒で塗りつぶして残像を作る
        ctx.fillStyle = 'rgba(2, 2, 5, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#0F6'; // 文字色 (サイバーグリーン)
        ctx.font = fontSize + 'px monospace';

        for(let i = 0; i < rainDrops.length; i++)
        {
            const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
            // x座標, y座標
            ctx.fillText(text, i*fontSize, rainDrops[i]*fontSize);
            
            // 画面下まで言ったらランダムに上に戻す
            if(rainDrops[i]*fontSize > canvas.height && Math.random() > 0.975){
                rainDrops[i] = 0;
            }
            rainDrops[i]++;
        }
    };
    // 30FPSで描画ループ
    setInterval(draw, 30);

    // ウィンドウリサイズ対応
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });


    // === 以下、既存のゲームロジック (変更なし) ===
    const tileContainer = document.getElementById('tile-container');
    const particleContainer = document.getElementById('particle-container');
    const counterDisplay = document.getElementById('counter');
    const movesDisplay = document.getElementById('moves');

    const PATH_LIST = [
        "M12 2L2 19h20L12 2z", "M3 3h18v18H3V3z", "M12 22a10 10 0 1 0 0-20 10 10 0 0 0 0 20z",
        "M12 2l3.1 6.3 6.9 1-5 4.9 1.2 6.9-6.2-3.3-6.2 3.3 1.2-6.9-5-4.9 6.9-1L12 2z",
        "M12 1L3 5v6c0 5.5 3.8 10.7 9 12 5.2-1.3 9-6.5 9-12V5l-9-4z", "M13 2L3 14h9l-1 9 10-12h-9l1-9z",
        "M12 2c-4 0-8 3.6-8 8 0 5.4 8 12 8 12s8-6.6 8-12c0-4.4-3.6-8-8-8z", "M21 4H3v16h18V4zM5 18V6h14v12H5z",
        "M12 1l-9 9 9 9 9-9-9-9z", "M18 4l2 2-8 8-8-8 2-2 6 6 6-6z", "M4 4h7v7H4V4zm9 0h7v7h-7V4zm0 9h7v7h-7v-7zm-9 0h7v7H4v-7z",
        "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z",
        "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z", "M11 7h2v2h-2V7zm0 4h2v6h-2v-6zm1-9C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z",
        "M12 6v3l4-4-4-4v3c-4.4 0-8 3.6-8 8 0 1.5.4 2.9 1.1 4l1.4-1.4c-.4-.8-.6-1.7-.6-2.6 0-3.3 2.7-6 6-6z", "M13 3h-2v10h2V3zm4.8 1.5l-1.4 1.4C17.9 7.3 19 9.5 19 12c0 3.9-3.1 7-7 7s-7-3.1-7-7c0-2.5 1.1-4.7 2.6-6.1L6.2 4.5C4.3 6.4 3 9.1 3 12c0 5 4 9 9 9s9-4 9-9c0-2.9-1.3-5.6-3.2-7.5z"
    ];
    const COLORS = ["var(--color-1)", "var(--color-2)", "var(--color-3)", "var(--color-4)"];
    let tilesData = []; let selectedTile = null; let remaining = 64;

    function createLayout() {
        const layout = [];
        for(let i=0; i<8; i++) for(let j=0; j<6; j++) layout.push({x: i, y: j, z: 0});
        for(let i=0; i<4; i++) for(let j=0; j<3; j++) layout.push({x: i+2, y: j+1.5, z: 1});
        for(let i=0; i<2; i++) for(let j=0; j<2; j++) layout.push({x: i+3, y: j+2, z: 2});
        return layout;
    }
    function isSelectable(tile, currentTiles) {
        const {x, y, z} = tile;
        const onTop = currentTiles.some(t => t.z > z && Math.abs(t.x - x) < 0.8 && Math.abs(t.y - y) < 0.8);
        if (onTop) return false;
        const leftBlocked = currentTiles.some(t => t.z === z && t.x === x - 1 && t.y === y);
        const rightBlocked = currentTiles.some(t => t.z === z && t.x === x + 1 && t.y === y);
        return !leftBlocked || !rightBlocked;
    }
    function checkMoves() {
        const activeTiles = tilesData.filter(t => !t.removed);
        const selectableTiles = activeTiles.filter(t => isSelectable(t, activeTiles));
        let pairCount = 0; const counts = {};
        selectableTiles.forEach(t => { const key = t.icon + t.color; counts[key] = (counts[key] || 0) + 1; });
        for (let key in counts) { pairCount += Math.floor(counts[key] / 2); }
        return pairCount;
    }

    function generateBoard() {
        let slots = createLayout(); const patternPool = [];
        for(let i=0; i<16; i++) { const p = { d: PATH_LIST[i], color: COLORS[i % COLORS.length] }; patternPool.push(p, p, p, p); }
        let board = []; let tempSlots = [...slots];
        while (tempSlots.length > 0) {
            let candidates = tempSlots.filter(s => isSelectable(s, tempSlots));
            if (candidates.length < 2) candidates = [tempSlots[0], tempSlots[1]];
            for (let i = 0; i < 2; i++) {
                let idx = Math.floor(Math.random() * candidates.length);
                let slot = candidates.splice(idx, 1)[0];
                tempSlots = tempSlots.filter(s => s !== slot);
                const pIdx = Math.floor(Math.random() * patternPool.length);
                const pattern = patternPool.splice(pIdx, 1)[0];
                board.push({ ...slot, icon: pattern.d, color: pattern.color, id: board.length, removed: false });
            }
        }
        return board;
    }

    function createParticles(tile) {
        const x = tile.x * 60 + 100 + (tile.z * 5) + 27;
        const y = tile.y * 80 + 40 - (tile.z * 5) + 37;
        for (let i = 0; i < 15; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.setProperty('--p-color', tile.color);
            p.style.left = `${x}px`;
            p.style.top = `${y}px`;
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 100 + 50;
            p.style.setProperty('--dx', Math.cos(angle) * dist + 'px');
            p.style.setProperty('--dy', Math.sin(angle) * dist + 'px');
            particleContainer.appendChild(p);
            setTimeout(() => p.remove(), 700);
        }
    }

    function render() {
        tileContainer.innerHTML = '';
        tilesData.forEach(tile => {
            if (tile.removed) return;
            const el = document.createElement('div');
            el.className = `tile ${tile.selected ? 'selected' : ''}`;
            el.style.left = `${tile.x * 60 + 100 + (tile.z * 5)}px`;
            el.style.top = `${tile.y * 80 + 40 - (tile.z * 5)}px`;
            el.style.zIndex = tile.z + 10;
            el.style.setProperty('--glow-color', tile.color);
            el.innerHTML = `<svg viewBox="0 0 24 24"><path d="${tile.icon}" fill="${tile.color}"></path></svg>`;
            el.onclick = () => handleTileClick(tile);
            tileContainer.appendChild(el);
        });

        const moves = checkMoves();
        counterDisplay.innerText = remaining;
        movesDisplay.innerText = moves;
        if (remaining > 0 && moves === 0) document.getElementById('fail-screen').style.display = 'flex';
        if (remaining === 0) document.getElementById('complete-screen').style.display = 'flex';
    }

    function handleTileClick(tile) {
        const activeTiles = tilesData.filter(t => !t.removed);
        if (!isSelectable(tile, activeTiles)) return;

        if (selectedTile === null) {
            tile.selected = true;
            selectedTile = tile;
        } else if (selectedTile.id === tile.id) {
            tile.selected = false;
            selectedTile = null;
        } else if (selectedTile.icon === tile.icon && selectedTile.color === tile.color) {
            createParticles(selectedTile);
            createParticles(tile);
            tile.removed = true;
            selectedTile.removed = true;
            selectedTile = null;
            remaining -= 2;
        } else {
            selectedTile.selected = false;
            tile.selected = true;
            selectedTile = tile;
        }
        render();
    }

    tilesData = generateBoard();
    render();
</script>
</body>
</html>